-- Custom types
CREATE TYPE public.user_role AS ENUM ('entrepreneur', 'investor');


-- Profiles table
CREATE TABLE if not exists public.profiles (
  id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  updated_at timestamp with time zone,
  full_name text,
  role user_role NOT NULL,
  -- Investor-specific fields
  bio text,
  preferred_sector text,
  investment_range text,
  expected_returns text,
  -- Common fields
  website_url text,
  linkedin_url text
);

-- Ideas table
CREATE TABLE if not exists public.ideas (
    id uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
    entrepreneur_id uuid NOT NULL REFERENCES public.profiles(id),
    idea_title text NOT NULL,
    anonymized_summary text NOT NULL,
    full_text text,
    sector text,
    investment_required text,
    estimated_returns text,
    prototype_url text,
    views integer DEFAULT 0,
    location text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone
);

-- Notifications table
CREATE TABLE if not exists public.notifications (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  recipient_id uuid NOT NULL REFERENCES public.profiles(id),
  sender_id uuid NOT NULL REFERENCES public.profiles(id),
  type text NOT NULL, -- e.g., 'APPROACH', 'NDA_ACCEPTED'
  content text,
  is_read boolean DEFAULT false,
  created_at timestamp with time zone DEFAULT now()
);


-- Function to create a profile when a new user signs up
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, role)
  VALUES (
    new.id,
    new.raw_user_meta_data->>'full_name',
    (new.raw_user_meta_data->>'role')::public.user_role
  );
  return new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to call the function on new user creation
CREATE OR REPLACE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


-- Storage bucket for idea prototypes
INSERT INTO storage.buckets (id, name, public)
VALUES ('idea_prototypes', 'idea_prototypes', false)
ON CONFLICT (id) DO NOTHING;

-- Policies for storage
CREATE POLICY "Allow authenticated users to upload" ON storage.objects FOR INSERT TO authenticated WITH CHECK (bucket_id = 'idea_prototypes');
CREATE POLICY "Allow owner to read their own files" ON storage.objects FOR SELECT USING (bucket_id = 'idea_prototypes' AND owner = auth.uid());


-- Row Level Security (RLS) policies

-- Enable RLS for all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ideas ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;


-- PROFILES table policies
DROP POLICY IF EXISTS "Users can view all profiles" ON public.profiles;
CREATE POLICY "Users can view all profiles" ON public.profiles FOR SELECT USING (true);

DROP POLICY IF EXISTS "Users can insert their own profile" ON public.profiles;
CREATE POLICY "Users can insert their own profile" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update their own profile" ON public.profiles;
CREATE POLICY "Users can update their own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Function to get user role
CREATE OR REPLACE FUNCTION get_user_role(user_id uuid)
RETURNS text AS $$
DECLARE
  user_role text;
BEGIN
  SELECT role::text INTO user_role FROM public.profiles WHERE id = user_id;
  RETURN user_role;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- IDEAS table policies
DROP POLICY IF EXISTS "Investors can view all ideas" ON public.ideas;
CREATE POLICY "Investors can view all ideas" ON public.ideas FOR SELECT USING (get_user_role(auth.uid()) = 'investor');

DROP POLICY IF EXISTS "Entrepreneurs can view their own ideas" ON public.ideas;
CREATE POLICY "Entrepreneurs can view their own ideas" ON public.ideas FOR SELECT USING (get_user_role(auth.uid()) = 'entrepreneur' AND auth.uid() = entrepreneur_id);

DROP POLICY IF EXISTS "Entrepreneurs can insert ideas" ON public.ideas;
CREATE POLICY "Entrepreneurs can insert ideas" ON public.ideas FOR INSERT WITH CHECK (get_user_role(auth.uid()) = 'entrepreneur' AND auth.uid() = entrepreneur_id);

DROP POLICY IF EXISTS "Entrepreneurs can update their own ideas" ON public.ideas;
CREATE POLICY "Entrepreneurs can update their own ideas" ON public.ideas FOR UPDATE USING (get_user_role(auth.uid()) = 'entrepreneur' AND auth.uid() = entrepreneur_id);


-- NOTIFICATIONS table policies
DROP POLICY IF EXISTS "Users can view their own notifications" ON public.notifications;
CREATE POLICY "Users can view their own notifications" ON public.notifications FOR SELECT USING (auth.uid() = recipient_id);

DROP POLICY IF EXISTS "Authenticated users can create notifications" ON public.notifications;
CREATE POLICY "Authenticated users can create notifications" ON public.notifications FOR INSERT WITH CHECK (auth.uid() = sender_id);


-- This is a helper function that we can use to dynamically execute SQL.
-- It is used to programmatically create policies.
-- See: https://supabase.com/docs/guides/database/functions#security-definer
CREATE OR REPLACE FUNCTION execute_sql(sql text)
RETURNS void
AS $$
BEGIN
    EXECUTE sql;
END;
$$
LANGUAGE plpgsql
SECURITY DEFINER;

-- Revoke execution from public and grant only to service_role
REVOKE ALL ON FUNCTION execute_sql(text) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION execute_sql(text) TO service_role;
