
-- =================================================================
--  VentureLink Database Schema
-- =================================================================
--  This script is idempotent and can be run multiple times safely.
--  It sets up tables, RLS policies, and helper functions.
-- =================================================================

-- 1. Create custom types
-- -----------------------------------------------------------------
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role') THEN
        CREATE TYPE public.user_role AS ENUM ('entrepreneur', 'investor');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type') THEN
        CREATE TYPE public.notification_type AS ENUM ('APPROACH', 'NDA_REQUEST', 'NDA_SIGNED', 'MESSAGE');
    END IF;
END
$$;

-- 2. Create profiles table
-- -----------------------------------------------------------------
--  Stores public-facing user information.
--  Synced with `auth.users` table via a trigger.
CREATE TABLE IF NOT EXISTS public.profiles (
    id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    updated_at timestamp with time zone,
    full_name text,
    avatar_url text,
    website_url text,
    linkedin_url text,
    bio text,
    role user_role,
    
    -- Investor-specific fields
    preferred_sector text,
    investment_range text,
    expected_returns text
);

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Profiles are viewable by everyone."
    ON public.profiles FOR SELECT
    USING (true);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile."
    ON public.profiles FOR INSERT
    WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update their own profile." ON publicprofiles;
CREATE POLICY "Users can update their own profile."
    ON public.profiles FOR UPDATE
    USING (auth.uid() = id)
    WITH CHECK (auth.uid() = id);

-- 3. Create ideas table
-- -----------------------------------------------------------------
--  Stores the startup ideas submitted by entrepreneurs.
CREATE TABLE IF NOT EXISTS public.ideas (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone,
    entrepreneur_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    idea_title text NOT NULL CHECK (char_length(idea_title) > 5),
    anonymized_summary text NOT NULL CHECK (char_length(anonymized_summary) > 20),
    full_text text,
    sector text,
    investment_required text,
    estimated_returns text,
    prototype_url text,
    views integer DEFAULT 0
);

ALTER TABLE public.ideas ENABLE ROW LEVEL SECURITY;

-- Policies for ideas table
DROP POLICY IF EXISTS "Ideas are viewable by authenticated users." ON public.ideas;
CREATE POLICY "Ideas are viewable by authenticated users."
    ON public.ideas FOR SELECT
    USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Entrepreneurs can insert their own ideas." ON public.ideas;
CREATE POLICY "Entrepreneurs can insert their own ideas."
    ON public.ideas FOR INSERT
    WITH CHECK (auth.uid() = entrepreneur_id AND (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'entrepreneur');

DROP POLICY IF EXISTS "Entrepreneurs can update their own ideas." ON public.ideas;
CREATE POLICY "Entrepreneurs can update their own ideas."
    ON public.ideas FOR UPDATE
    USING (auth.uid() = entrepreneur_id)
    WITH CHECK (auth.uid() = entrepreneur_id);

DROP POLICY IF EXISTS "Entrepreneurs can delete their own ideas." ON public.ideas;
CREATE POLICY "Entrepreneurs can delete their own ideas."
    ON public.ideas FOR DELETE
    USING (auth.uid() = entrepreneur_id);


-- 4. Create notifications table
-- -----------------------------------------------------------------
--  Stores notifications for users (e.g., approaches, messages).
CREATE TABLE IF NOT EXISTS public.notifications (
    id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    recipient_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    sender_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    idea_id uuid REFERENCES public.ideas(id) ON DELETE SET NULL,
    type notification_type NOT NULL,
    content text,
    is_read boolean DEFAULT false
);

ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

-- Policies for notifications table
DROP POLICY IF EXISTS "Users can view their own notifications." ON public.notifications;
CREATE POLICY "Users can view their own notifications."
    ON public.notifications FOR SELECT
    USING (auth.uid() = recipient_id);

DROP POLICY IF EXISTS "Authenticated users can create notifications." ON public.notifications;
CREATE POLICY "Authenticated users can create notifications."
    ON public.notifications FOR INSERT
    WITH CHECK (auth.role() = 'authenticated' AND auth.uid() = sender_id);
    
DROP POLICY IF EXISTS "Users can mark their own notifications as read." ON public.notifications;
CREATE POLICY "Users can mark their own notifications as read."
    ON public.notifications FOR UPDATE
    USING (auth.uid() = recipient_id)
    WITH CHECK (auth.uid() = recipient_id);


-- 5. Set up trigger to automatically create a profile on user creation
-- -----------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, role)
  VALUES (new.id, new.raw_user_meta_data->>'full_name', (new.raw_user_meta_data->>'role')::user_role);
  RETURN new;
END;
$$;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- 6. Set up storage for idea prototypes
-- -----------------------------------------------------------------
INSERT INTO storage.buckets (id, name, public)
VALUES ('idea_prototypes', 'idea_prototypes', false)
ON CONFLICT (id) DO NOTHING;

-- Policies for storage
DROP POLICY IF EXISTS "Entrepreneurs can upload to their own folder." ON storage.objects;
CREATE POLICY "Entrepreneurs can upload to their own folder."
    ON storage.objects FOR INSERT TO authenticated
    WITH CHECK (bucket_id = 'idea_prototypes' AND (storage.foldername(name))[1] = auth.uid()::text);

DROP POLICY IF EXISTS "Users can view files they have access to." ON storage.objects;
CREATE POLICY "Users can view files they have access to."
    ON storage.objects FOR SELECT TO authenticated
    USING (
      bucket_id = 'idea_prototypes' AND
      -- Entrepreneurs can see their own files
      (storage.foldername(name))[1] = auth.uid()::text
      -- In a real app, you would add logic for investors who have signed an NDA,
      -- e.g., checking an `nda_signatures` table.
      -- OR ( (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'investor' )
    );

-- 7. RPC function for executing arbitrary SQL (for seeding)
-- This is a security risk in production if not properly secured.
-- For this demo, it's used by an admin role to run the seed script.
-- -----------------------------------------------------------------
CREATE OR REPLACE FUNCTION execute_sql(sql text)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  EXECUTE sql;
END;
$$;
-- Revoke execution from public and grant only to service_role
REVOKE ALL ON FUNCTION execute_sql(text) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION execute_sql(text) TO service_role;

    