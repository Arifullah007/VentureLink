-- Create custom types
create type public.user_role as enum ('entrepreneur', 'investor');
create type public.investment_range as enum ('70K-5L', '5L-25L', '26L-1CR', '1CR+');
create type public.expected_returns as enum ('Less', 'Medium', 'High');

-- USERS & PROFILES
-- This table stores public profile data for users.
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  updated_at timestamp with time zone,
  full_name text,
  avatar_url text,
  website_url text,
  linkedin_url text,
  role user_role not null,
  -- Investor-specific fields
  bio text,
  preferred_sector text,
  investment_range investment_range,
  expected_returns expected_returns
);

-- Function to create a public profile for a new user.
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id, full_name, role)
  values (
    new.id,
    new.raw_user_meta_data ->> 'full_name',
    (new.raw_user_meta_data ->> 'role')::user_role
  );
  return new;
end;
$$;

-- Trigger to call the function when a new user is created.
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Enable Row Level Security (RLS)
alter table public.profiles enable row level security;

-- Policies for profiles
drop policy if exists "Public profiles are viewable by everyone." on public.profiles;
create policy "Public profiles are viewable by everyone." on public.profiles
  for select using (true);

drop policy if exists "Users can insert their own profile." on public.profiles;
create policy "Users can insert their own profile." on public.profiles
  for insert with check (auth.uid() = id);

drop policy if exists "Users can update own profile." on public.profiles;
create policy "Users can update own profile." on public.profiles
  for update using (auth.uid() = id);


-- IDEAS
-- This table stores the ideas submitted by entrepreneurs.
create table if not exists public.ideas (
    id uuid primary key default gen_random_uuid(),
    created_at timestamp with time zone default now(),
    idea_title text not null,
    anonymized_summary text not null,
    full_text text,
    sector text,
    investment_required investment_range,
    estimated_returns expected_returns,
    prototype_url text,
    entrepreneur_id uuid not null references public.profiles(id) on delete cascade
);

-- Enable RLS for ideas
alter table public.ideas enable row level security;

-- Policies for ideas
drop policy if exists "Allow logged-in users to read all ideas." on public.ideas;
create policy "Allow logged-in users to read all ideas." on public.ideas
    for select using (auth.role() = 'authenticated');

drop policy if exists "Entrepreneurs can insert their own ideas." on public.ideas;
create policy "Entrepreneurs can insert their own ideas." on public.ideas
    for insert with check (
        auth.uid() = entrepreneur_id and
        (select role from public.profiles where id = auth.uid()) = 'entrepreneur'
    );

drop policy if exists "Entrepreneurs can update their own ideas." on public.ideas;
create policy "Entrepreneurs can update their own ideas." on public.ideas
    for update using (
        auth.uid() = entrepreneur_id and
        (select role from public.profiles where id = auth.uid()) = 'entrepreneur'
    );

drop policy if exists "Entrepreneurs can delete their own ideas." on public.ideas;
create policy "Entrepreneurs can delete their own ideas." on public.ideas
    for delete using (
        auth.uid() = entrepreneur_id and
        (select role from public.profiles where id = auth.uid()) = 'entrepreneur'
    );


-- NOTIFICATIONS
-- This table stores notifications for users.
create table if not exists public.notifications (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone default now(),
    recipient_id uuid not null references public.profiles(id) on delete cascade,
    sender_id uuid references public.profiles(id) on delete cascade,
    idea_id uuid references public.ideas(id) on delete cascade,
    notification_type text not null, -- e.g., 'NDA_REQUEST', 'NDA_ACCEPTED', 'GROUP_INVITE'
    content jsonb,
    is_read boolean default false
);

-- Enable RLS for notifications
alter table public.notifications enable row level security;

-- Policies for notifications
drop policy if exists "Users can view their own notifications." on public.notifications;
create policy "Users can view their own notifications." on public.notifications
    for select using (auth.uid() = recipient_id);

drop policy if exists "Users can update their own notifications (e.g., mark as read)." on public.notifications;
create policy "Users can update their own notifications (e.g., mark as read)." on public.notifications
    for update using (auth.uid() = recipient_id);

drop policy if exists "Authenticated users can create notifications." on public.notifications;
create policy "Authenticated users can create notifications." on public.notifications
    for insert with check (auth.role() = 'authenticated');

-- This function will be called by a trigger when a user is deleted from auth.users
create or replace function public.delete_user_data()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  -- Delete all data associated with the user.
  -- The 'on delete cascade' on the profiles table will handle the rest.
  -- We just need to delete the profile record.
  delete from public.profiles where id = old.id;
  return old;
end;
$$;

-- This trigger calls the function BEFORE a user is deleted
drop trigger if exists on_auth_user_deleted on auth.users;
create trigger on_auth_user_deleted
  before delete on auth.users
  for each row execute procedure public.delete_user_data();
